package com.homebrain.agent.domain.planning

import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import com.homebrain.agent.domain.conversation.CodeProposal
import com.homebrain.agent.domain.conversation.FileProposal

/**
 * Code generated by the LLM.
 * 
 * Includes attempt tracking for the validation/fix loop.
 * The GOAP planner will rerun fixInvalidCode() while codeIsInvalid
 * and canStillRetry conditions are true.
 */
@JsonClassDescription("Generated automation code with validation tracking")
data class GeneratedCode(
    @get:JsonPropertyDescription("The generated files (automation and/or library)")
    val files: List<FileProposal>,
    
    @get:JsonPropertyDescription("Summary of what the code does")
    val summary: String,
    
    @get:JsonPropertyDescription("Current attempt number (1 = first generation, 2+ = after fixes)")
    val attempt: Int = 1
) {
    init {
        require(files.isNotEmpty()) { "At least one file must be generated" }
        require(summary.isNotBlank()) { "Summary cannot be blank" }
        require(attempt >= 1) { "Attempt must be at least 1" }
    }
    
    /**
     * Create a new GeneratedCode with incremented attempt counter.
     */
    fun withIncrementedAttempt(): GeneratedCode = copy(attempt = attempt + 1)
    
    /**
     * Create a new GeneratedCode with updated files.
     */
    fun withFiles(newFiles: List<FileProposal>): GeneratedCode = copy(files = newFiles)
    
    /**
     * Check if this is the first generation (not a fix attempt).
     */
    fun isFirstAttempt(): Boolean = attempt == 1
    
    /**
     * Get all automation files.
     */
    fun automations(): List<FileProposal> = files.filter { it.isAutomation() }
    
    /**
     * Get all library files.
     */
    fun libraries(): List<FileProposal> = files.filter { it.isLibrary() }
    
    /**
     * Convert to a CodeProposal for the final response.
     */
    fun toCodeProposal(): CodeProposal = CodeProposal(
        summary = summary,
        files = files
    )
    
    companion object {
        /**
         * Create a simple single-file automation.
         */
        fun singleAutomation(code: String, filename: String, summary: String) = GeneratedCode(
            files = listOf(FileProposal.automation(code, filename)),
            summary = summary
        )
        
        /**
         * Create from a code proposal.
         */
        fun fromProposal(proposal: CodeProposal, attempt: Int = 1) = GeneratedCode(
            files = proposal.files,
            summary = proposal.summary,
            attempt = attempt
        )
    }
}

/**
 * Internal response type for LLM JSON extraction when generating code.
 */
@JsonClassDescription("Generated code response from the LLM")
data class GeneratedCodeResponse(
    @get:JsonPropertyDescription("Brief summary of what the code does")
    val summary: String,
    
    @get:JsonPropertyDescription("The generated files")
    val files: List<GeneratedFileResponse>
)

/**
 * A single file in the generated code response.
 */
@JsonClassDescription("A generated file")
data class GeneratedFileResponse(
    @get:JsonPropertyDescription("The Starlark code")
    val code: String,
    
    @get:JsonPropertyDescription("Filename (e.g., 'motion_light.star' or 'lib/helpers.lib.star')")
    val filename: String,
    
    @get:JsonPropertyDescription("Type: 'automation' or 'library'")
    val type: String
)

/**
 * Response from the library extraction LLM.
 */
@JsonClassDescription("Library extraction result")
data class ExtractionResponse(
    @get:JsonPropertyDescription("Whether any extraction was performed")
    val extracted: Boolean,
    
    @get:JsonPropertyDescription("Summary of what was extracted")
    val summary: String,
    
    @get:JsonPropertyDescription("The files after extraction (may include new library files)")
    val files: List<GeneratedFileResponse>
)
